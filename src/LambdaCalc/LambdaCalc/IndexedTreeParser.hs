-- File generated by the BNF Converter (bnfc 2.9.4.1).

-- Templates for pattern matching on abstract syntax

{-# OPTIONS_GHC -fno-warn-unused-matches #-}

module LambdaCalc.IndexedTreeParser where

import Prelude (($), Either(..), String, (++), Show, show)
import qualified LambdaCalc.LambdaCalculus.Abs
import LambdaCalc.LambdaCalculus.Abs ( Program(..), Term(..), Ident(..), Variable(..) )


parseIdent :: Ident -> Ident
parseIdent x = case x of
  Ident string -> Ident string

parseProgram :: Program -> Program
parseProgram x = case x of
  AProgram term -> AProgram (parseTerm term)

parseTerm :: Term -> TermResult
parseTerm x = case x of
  Var variable -> Var (parseTerm term)
  IntConst integer -> IntConst integer 
  DoubleConst double -> DoubleConst double
  Binder variable term -> Binder (parseVariable variable) (parseTerm term)
  Application term1 term2 -> Application (parseTerm term1) (parseTerm term2)
    -- newTerm1 <- substTerm term1 substNumber newTerm
    -- newTerm2 <- substTerm term2 substNumber newTerm
    -- case newTerm1 of 
    --   Binder v binderTerm -> do 
    --     notUpdatedIdexs <- substTerm binderTerm 0 (Just newTerm2)
    --     Right (shiftTerm notUpdatedIdexs (0) (\x -> x + (-1))) 
    --   _ -> Right (Application newTerm1 newTerm2)
    
  Plus term1 term2 -> Plus (parseTerm term1) (parseTerm term2)
  Minus term1 term2 -> Minus (parseTerm term1) (parseTerm term2)

parseVariable :: Variable -> Variable
parseVariable x = case x of
  Identifier ident -> Identifier ident
  Bound integer -> Bound integer
