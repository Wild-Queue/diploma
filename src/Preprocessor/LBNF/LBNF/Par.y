-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.4.1).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module LBNF.LBNF.Par
  ( happyError
  , myLexer
  , pGrammar
  , pListDef
  , pListItem
  , pDef
  , pItem
  , pCat
  , pLabel
  , pLabelId
  , pProfItem
  , pIntList
  , pListInteger
  , pListIntList
  , pListProfItem
  , pVariableType
  , pListString
  , pListRHS
  , pRHS
  , pMinimumSize
  , pReg2
  , pReg1
  , pReg3
  , pReg
  , pListIdent
  ) where

import Prelude

import qualified LBNF.LBNF.Abs
import LBNF.LBNF.Lex

}

%name pGrammar Grammar
%name pListDef ListDef
%name pListItem ListItem
%name pDef Def
%name pItem Item
%name pCat Cat
%name pLabel Label
%name pLabelId LabelId
%name pProfItem ProfItem
%name pIntList IntList
%name pListInteger ListInteger
%name pListIntList ListIntList
%name pListProfItem ListProfItem
%name pVariableType VariableType
%name pListString ListString
%name pListRHS ListRHS
%name pRHS RHS
%name pMinimumSize MinimumSize
%name pReg2 Reg2
%name pReg1 Reg1
%name pReg3 Reg3
%name pReg Reg
%name pListIdent ListIdent
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '('           { PT _ (TS _ 1)  }
  ')'           { PT _ (TS _ 2)  }
  '*'           { PT _ (TS _ 3)  }
  '+'           { PT _ (TS _ 4)  }
  ','           { PT _ (TS _ 5)  }
  '-'           { PT _ (TS _ 6)  }
  '.'           { PT _ (TS _ 7)  }
  ':'           { PT _ (TS _ 8)  }
  '::='         { PT _ (TS _ 9)  }
  ';'           { PT _ (TS _ 10) }
  '?'           { PT _ (TS _ 11) }
  '['           { PT _ (TS _ 12) }
  ']'           { PT _ (TS _ 13) }
  '_'           { PT _ (TS _ 14) }
  'binder'      { PT _ (TS _ 15) }
  'char'        { PT _ (TS _ 16) }
  'coercions'   { PT _ (TS _ 17) }
  'comment'     { PT _ (TS _ 18) }
  'digit'       { PT _ (TS _ 19) }
  'entrypoints' { PT _ (TS _ 20) }
  'eps'         { PT _ (TS _ 21) }
  'internal'    { PT _ (TS _ 22) }
  'layout'      { PT _ (TS _ 23) }
  'letter'      { PT _ (TS _ 24) }
  'lower'       { PT _ (TS _ 25) }
  'name'        { PT _ (TS _ 26) }
  'nonempty'    { PT _ (TS _ 27) }
  'position'    { PT _ (TS _ 28) }
  'rules'       { PT _ (TS _ 29) }
  'scope'       { PT _ (TS _ 30) }
  'separator'   { PT _ (TS _ 31) }
  'stop'        { PT _ (TS _ 32) }
  'terminator'  { PT _ (TS _ 33) }
  'token'       { PT _ (TS _ 34) }
  'toplevel'    { PT _ (TS _ 35) }
  'upper'       { PT _ (TS _ 36) }
  'variable'    { PT _ (TS _ 37) }
  '{'           { PT _ (TS _ 38) }
  '|'           { PT _ (TS _ 39) }
  '}'           { PT _ (TS _ 40) }
  L_Ident       { PT _ (TV $$)   }
  L_charac      { PT _ (TC $$)   }
  L_integ       { PT _ (TI $$)   }
  L_quoted      { PT _ (TL $$)   }

%%

Ident :: { LBNF.LBNF.Abs.Ident }
Ident  : L_Ident { LBNF.LBNF.Abs.Ident $1 }

Char    :: { Char }
Char     : L_charac { (read $1) :: Char }

Integer :: { Integer }
Integer  : L_integ  { (read $1) :: Integer }

String  :: { String }
String   : L_quoted { $1 }

Grammar :: { LBNF.LBNF.Abs.Grammar }
Grammar : ListDef { LBNF.LBNF.Abs.MkGrammar $1 }

ListDef :: { [LBNF.LBNF.Abs.Def] }
ListDef : {- empty -} { [] } | Def ';' ListDef { (:) $1 $3 }

ListItem :: { [LBNF.LBNF.Abs.Item] }
ListItem : {- empty -} { [] } | Item ListItem { (:) $1 $2 }

Def :: { LBNF.LBNF.Abs.Def }
Def
  : Label '.' Cat '::=' ListItem { LBNF.LBNF.Abs.Rule $1 $3 $5 }
  | 'comment' String { LBNF.LBNF.Abs.Comment $2 }
  | 'comment' String String { LBNF.LBNF.Abs.Comments $2 $3 }
  | 'internal' Label '.' Cat '::=' ListItem { LBNF.LBNF.Abs.Internal $2 $4 $6 }
  | 'token' Ident Reg { LBNF.LBNF.Abs.Token $2 $3 }
  | 'position' 'token' Ident Reg { LBNF.LBNF.Abs.PosToken $3 $4 }
  | 'entrypoints' ListIdent { LBNF.LBNF.Abs.Entryp $2 }
  | 'separator' MinimumSize Cat String { LBNF.LBNF.Abs.Separator $2 $3 $4 }
  | 'terminator' MinimumSize Cat String { LBNF.LBNF.Abs.Terminator $2 $3 $4 }
  | 'coercions' Ident Integer { LBNF.LBNF.Abs.Coercions $2 $3 }
  | 'rules' Ident '::=' ListRHS { LBNF.LBNF.Abs.Rules $2 $4 }
  | 'variable' VariableType Cat { LBNF.LBNF.Abs.Variable $2 $3 }
  | 'layout' ListString { LBNF.LBNF.Abs.Layout $2 }
  | 'layout' 'stop' ListString { LBNF.LBNF.Abs.LayoutStop $3 }
  | 'layout' 'toplevel' { LBNF.LBNF.Abs.LayoutTop }

Item :: { LBNF.LBNF.Abs.Item }
Item
  : String { LBNF.LBNF.Abs.Terminal $1 }
  | Cat { LBNF.LBNF.Abs.NTerminal $1 }

Cat :: { LBNF.LBNF.Abs.Cat }
Cat
  : '[' Cat ']' { LBNF.LBNF.Abs.ListCat $2 }
  | Ident { LBNF.LBNF.Abs.IdCat $1 }

Label :: { LBNF.LBNF.Abs.Label }
Label
  : LabelId { LBNF.LBNF.Abs.LabNoP $1 }
  | LabelId ListProfItem { LBNF.LBNF.Abs.LabP $1 $2 }
  | LabelId LabelId ListProfItem { LBNF.LBNF.Abs.LabPF $1 $2 $3 }
  | LabelId LabelId { LBNF.LBNF.Abs.LabF $1 $2 }

LabelId :: { LBNF.LBNF.Abs.LabelId }
LabelId
  : Ident { LBNF.LBNF.Abs.Id $1 }
  | '_' { LBNF.LBNF.Abs.Wild }
  | '[' ']' { LBNF.LBNF.Abs.ListE }
  | '(' ':' ')' { LBNF.LBNF.Abs.ListCons }
  | '(' ':' '[' ']' ')' { LBNF.LBNF.Abs.ListOne }

ProfItem :: { LBNF.LBNF.Abs.ProfItem }
ProfItem
  : '(' '[' ListIntList ']' ',' '[' ListInteger ']' ')' { LBNF.LBNF.Abs.ProfIt $3 $7 }

IntList :: { LBNF.LBNF.Abs.IntList }
IntList : '[' ListInteger ']' { LBNF.LBNF.Abs.Ints $2 }

ListInteger :: { [Integer] }
ListInteger
  : {- empty -} { [] }
  | Integer { (:[]) $1 }
  | Integer ',' ListInteger { (:) $1 $3 }

ListIntList :: { [LBNF.LBNF.Abs.IntList] }
ListIntList
  : {- empty -} { [] }
  | IntList { (:[]) $1 }
  | IntList ',' ListIntList { (:) $1 $3 }

ListProfItem :: { [LBNF.LBNF.Abs.ProfItem] }
ListProfItem
  : ProfItem { (:[]) $1 } | ProfItem ListProfItem { (:) $1 $2 }

VariableType :: { LBNF.LBNF.Abs.VariableType }
VariableType
  : 'scope' { LBNF.LBNF.Abs.VarScope }
  | 'name' { LBNF.LBNF.Abs.VarName }
  | 'binder' { LBNF.LBNF.Abs.VarBinder }

ListString :: { [String] }
ListString
  : String { (:[]) $1 } | String ',' ListString { (:) $1 $3 }

ListRHS :: { [LBNF.LBNF.Abs.RHS] }
ListRHS : RHS { (:[]) $1 } | RHS '|' ListRHS { (:) $1 $3 }

RHS :: { LBNF.LBNF.Abs.RHS }
RHS : ListItem { LBNF.LBNF.Abs.MkRHS $1 }

MinimumSize :: { LBNF.LBNF.Abs.MinimumSize }
MinimumSize
  : 'nonempty' { LBNF.LBNF.Abs.MNonempty }
  | {- empty -} { LBNF.LBNF.Abs.MEmpty }

Reg2 :: { LBNF.LBNF.Abs.Reg }
Reg2 : Reg2 Reg3 { LBNF.LBNF.Abs.RSeq $1 $2 } | Reg3 { $1 }

Reg1 :: { LBNF.LBNF.Abs.Reg }
Reg1
  : Reg1 '|' Reg2 { LBNF.LBNF.Abs.RAlt $1 $3 }
  | Reg2 '-' Reg2 { LBNF.LBNF.Abs.RMinus $1 $3 }
  | Reg2 { $1 }

Reg3 :: { LBNF.LBNF.Abs.Reg }
Reg3
  : Reg3 '*' { LBNF.LBNF.Abs.RStar $1 }
  | Reg3 '+' { LBNF.LBNF.Abs.RPlus $1 }
  | Reg3 '?' { LBNF.LBNF.Abs.ROpt $1 }
  | 'eps' { LBNF.LBNF.Abs.REps }
  | Char { LBNF.LBNF.Abs.RChar $1 }
  | '[' String ']' { LBNF.LBNF.Abs.RAlts $2 }
  | '{' String '}' { LBNF.LBNF.Abs.RSeqs $2 }
  | 'digit' { LBNF.LBNF.Abs.RDigit }
  | 'letter' { LBNF.LBNF.Abs.RLetter }
  | 'upper' { LBNF.LBNF.Abs.RUpper }
  | 'lower' { LBNF.LBNF.Abs.RLower }
  | 'char' { LBNF.LBNF.Abs.RAny }
  | '(' Reg ')' { $2 }

Reg :: { LBNF.LBNF.Abs.Reg }
Reg : Reg1 { $1 }

ListIdent :: { [LBNF.LBNF.Abs.Ident] }
ListIdent : Ident { (:[]) $1 } | Ident ',' ListIdent { (:) $1 $3 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

