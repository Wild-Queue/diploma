-- File generated by the BNF Converter (bnfc 2.9.4.1).

-- Templates for pattern matching on abstract syntax

{-# OPTIONS_GHC -fno-warn-unused-matches #-}

module LambdaCalc.Analyser where

import Prelude (($), Either(..), String, (++), Show, show, Integer, Maybe (..), fst, snd, otherwise, (==), (+))
import qualified LambdaCalc.LambdaCalculus.Abs

type Result = Either String LambdaCalc.LambdaCalculus.Abs.Program

updateValues :: [(String, Integer)] -> [(String, Integer)]
updateValues [] = []
updateValues (x:xs) = (fst x, snd x + 1) : updateValues xs

printValues :: [(String, Integer)] -> String
printValues [] = ""
printValues (x:xs) = (fst x) ++ " => " ++ show (snd x) ++ "\n" ++ printValues xs

returnIndex :: [(String, Integer)] -> String -> Maybe Integer
returnIndex [] value = Nothing
returnIndex (x:xs) value
    | fst x == value = Just (snd x)
    | otherwise = returnIndex xs value


failure :: Show a => a -> Either String String
failure x = Left $ "Undefined case: " ++ show x

addValue :: [(String, Integer)] -> String -> [(String, Integer)]
addValue [] value = [(value, 0)]
addValue (x:xs) value 
  | fst x == value = (fst x, 0) : xs
  | otherwise = x : (addValue xs value)



transIdent :: LambdaCalc.LambdaCalculus.Abs.Ident -> Either String LambdaCalc.LambdaCalculus.Abs.Ident
transIdent x = case x of
  LambdaCalc.LambdaCalculus.Abs.Ident string -> Right (LambdaCalc.LambdaCalculus.Abs.Ident string)
  _ -> Left $ "Unexpected case: " ++ show x

transProgram :: LambdaCalc.LambdaCalculus.Abs.Program -> Either String LambdaCalc.LambdaCalculus.Abs.Program
transProgram x = case x of
    LambdaCalc.LambdaCalculus.Abs.AProgram term -> do 
      case transTerm term [] of 
        Left err -> Left err
        Right terms -> Right (LambdaCalc.LambdaCalculus.Abs.AProgram terms)
    _ -> Left $ "Unexpected case: " ++ show x

transTerm :: LambdaCalc.LambdaCalculus.Abs.Term -> [(String, Integer)] -> Either String LambdaCalc.LambdaCalculus.Abs.Term
transTerm x nameDict = case x of
  LambdaCalc.LambdaCalculus.Abs.Var variable -> 
    case transVariable variable nameDict of 
      Left err -> Left err
      Right newVar -> Right (LambdaCalc.LambdaCalculus.Abs.Var newVar)
  LambdaCalc.LambdaCalculus.Abs.IntConst integer -> Right (LambdaCalc.LambdaCalculus.Abs.IntConst integer)
  LambdaCalc.LambdaCalculus.Abs.DoubleConst double -> Right (LambdaCalc.LambdaCalculus.Abs.DoubleConst double)
  LambdaCalc.LambdaCalculus.Abs.Binder variable term -> do 
    case variable of 
      LambdaCalc.LambdaCalculus.Abs.Identifier (LambdaCalc.LambdaCalculus.Abs.Ident varName) ->
        case transTerm term (addValue (updateValues nameDict) varName) of 
          Left err -> Left err
          Right term -> Right (LambdaCalc.LambdaCalculus.Abs.Binder (LambdaCalc.LambdaCalculus.Abs.Identifier (LambdaCalc.LambdaCalculus.Abs.Ident "")) term)
      
  LambdaCalc.LambdaCalculus.Abs.Application term1 term2 -> do 
    case transTerm term1 nameDict of 
      Left err -> Left err
      Right updatedTerm1 -> do 
        case transTerm term2 nameDict of
          Left err -> Left err
          Right updatedTerm2 -> Right (LambdaCalc.LambdaCalculus.Abs.Application updatedTerm1 updatedTerm2)

  LambdaCalc.LambdaCalculus.Abs.Plus term1 term2 -> do 
    case transTerm term1 nameDict of 
      Left err -> Left err
      Right updatedTerm1 -> do 
        case transTerm term2 nameDict of
          Left err -> Left err
          Right updatedTerm2 -> Right (LambdaCalc.LambdaCalculus.Abs.Plus updatedTerm1 updatedTerm2)

  LambdaCalc.LambdaCalculus.Abs.Minus term1 term2 ->  do 
    case transTerm term1 nameDict of 
      Left err -> Left err
      Right updatedTerm1 -> do 
        case transTerm term2 nameDict of
          Left err -> Left err
          Right updatedTerm2 -> Right (LambdaCalc.LambdaCalculus.Abs.Minus updatedTerm1 updatedTerm2)

transVariable :: LambdaCalc.LambdaCalculus.Abs.Variable -> [(String, Integer)] -> Either String LambdaCalc.LambdaCalculus.Abs.Variable
transVariable x nameDict = case x of
  LambdaCalc.LambdaCalculus.Abs.Identifier ident -> 
    case transIdent ident of
      Right (LambdaCalc.LambdaCalculus.Abs.Ident string) -> 
        case returnIndex nameDict string of 
          Nothing -> Right (LambdaCalc.LambdaCalculus.Abs.Identifier ident)
          Just index -> Right (LambdaCalc.LambdaCalculus.Abs.Bound index)
      _ -> Left $ "Unexpected case: " ++ show x;
  LambdaCalc.LambdaCalculus.Abs.Bound integer -> Right (LambdaCalc.LambdaCalculus.Abs.Bound integer)