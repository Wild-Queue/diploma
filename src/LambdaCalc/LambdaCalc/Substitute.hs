-- File generated by the BNF Converter (bnfc 2.9.4.1).

-- Templates for pattern matching on abstract syntax

{-# OPTIONS_GHC -fno-warn-unused-matches #-}

module LambdaCalc.Substitute where

import Prelude (($), Either(..), String, (++), Show, show, Integer, Maybe (..), fst, snd, otherwise, (==), (+))
import qualified LambdaCalc.LambdaCalculus.Abs
import LambdaCalc.LambdaCalculus.Abs ( Program(..), Term(..), Ident(..), Variable(..) )
import LambdaCalc.ShiftFunction ( shiftTerm )


substIdent :: Ident -> Ident
substIdent x = case x of
  Ident string -> Ident string

substTerm :: Term -> Integer -> Term -> Term
substTerm x substIndex newTerm = case x of
  Var variable ->
    case substVariable variable of 
      Left identifier -> Var identifier
      Right index -> 
        if substIndex == index 
          then newTerm
          else Var (Bound index)

  IntConst integer -> IntConst integer
  DoubleConst double -> DoubleConst double
  Binder variable term -> do
    let upShiftedTerm = shiftTerm newTerm 0 (\x -> x + 1) -- lambda . (lambda (1 0)) <- 1 => lambda (1 0) <- 1 [=>] (1 0) <- 2 => lambda (2 0)
    Binder variable (substTerm term (substIndex+1) upShiftedTerm) 

  Application term1 term2 -> do 
    let newTerm1 = substTerm term1 substIndex newTerm
    let newTerm2 = substTerm term2 substIndex newTerm
    case newTerm1 of 
      Binder v binderTerm -> do 
        let beforeDownShift = substTerm binderTerm 0 newTerm2
        shiftTerm beforeDownShift 1 (\x -> x + (-1))
      _ -> Application newTerm1 newTerm2

  Plus term1 term2 -> 
    Plus (substTerm term1 substIndex newTerm) (substTerm term2 substIndex newTerm)

  Minus term1 term2 -> 
    Minus (substTerm term1 substIndex newTerm) (substTerm term2 substIndex newTerm)

substVariable :: Variable -> Either Variable Integer
substVariable x = case x of
  Identifier ident -> Left (Identifier (substIdent ident))
  Bound integer -> Right integer
