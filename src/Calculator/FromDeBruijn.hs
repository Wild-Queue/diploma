-- File generated by the BNF Converter (bnfc 2.9.4.1).

-- Templates for pattern matching on abstract syntax

{-# OPTIONS_GHC -fno-warn-unused-matches #-}

module FromDeBruijn where

import Prelude (($), Either(..), String, (++), Show, fromIntegral, show, Integer, Maybe (..), fst, snd, mod, otherwise, (==), (<), (+), map, foldr, Num (fromInteger), Integral (toInteger), Foldable (foldl), const, length)
import Data.Char (chr)
import Data.Text.Internal.Fusion (Stream, index, length)
import qualified LCalc.LambdaCalculus.Abs as LCalculus
import qualified DBruijnCalc.DeBruijnGrammar.Abs as DBCalculus


upShiftDict :: [(Integer, String)] -> [(Integer, String)]
upShiftDict = map (\ x -> (fst x + 1, snd x))

returnIdentifier :: [(Integer, String)] -> Integer -> Maybe String
returnIdentifier [] indx = Nothing
returnIdentifier (x:xs) indx
    | fst x == indx = Just (snd x)
    | otherwise = returnIdentifier xs indx

intToString :: Integer -> String
intToString n 
    | n < 0 = []
    | otherwise = chr (97 + (fromIntegral n `mod` 26)) : intToString (n + (-26))

addIdentifier :: [(Integer, String)] -> Integer -> [(Integer, String)]
addIdentifier xs length = foldr (:) [(0, intToString length)] xs


fromDeBruijnIdent :: DBCalculus.Ident -> LCalculus.Ident
fromDeBruijnIdent x = case x of
  DBCalculus.Ident string -> LCalculus.Ident string

fromDeBruijn :: DBCalculus.Program -> LCalculus.Program
fromDeBruijn prog = case prog of
    DBCalculus.AProgram terms -> LCalculus.AProgram (map (\ x -> fromDeBruijnTerm x []) terms)

fromDeBruijnTerm :: DBCalculus.Term -> [(Integer, String)] -> LCalculus.Term
fromDeBruijnTerm x nameDict = case x of
  DBCalculus.Var variable -> LCalculus.Var (fromDeBruijnVariable variable nameDict) 
  DBCalculus.Lam term -> do 
    let dictTermScope = upShiftDict nameDict
    let dictLength = toInteger (Prelude.length dictTermScope)
    let dictWithVar = addIdentifier dictTermScope dictLength
    case term of 
      DBCalculus.ScopedTerm term -> do
        let updatedTerm = fromDeBruijnTerm term dictWithVar 
        LCalculus.Lam (LCalculus.PatternVar (LCalculus.VarIdent (LCalculus.Ident (intToString dictLength)))) (LCalculus.ScopedTerm updatedTerm)
      
  DBCalculus.Let term1 term2 -> do
    let updatedTerm1 = fromDeBruijnTerm term1 nameDict 

    let dictTermScope = upShiftDict nameDict
    let dictLength = toInteger (Prelude.length dictTermScope)
    let dictWithVar = addIdentifier dictTermScope dictLength
    case term2 of 
      DBCalculus.ScopedTerm term2 -> do
        let updatedTerm2 = fromDeBruijnTerm term2 dictWithVar 
        LCalculus.Let (LCalculus.PatternVar (LCalculus.VarIdent (LCalculus.Ident (intToString dictLength)))) updatedTerm1 (LCalculus.ScopedTerm updatedTerm2)

  DBCalculus.Application term1 term2 -> do 
    let updatedTerm1 = fromDeBruijnTerm term1 nameDict 
    let updatedTerm2 = fromDeBruijnTerm term2 nameDict 
    LCalculus.Application updatedTerm1 updatedTerm2

fromDeBruijnScopedTerm :: DBCalculus.ScopedTerm -> [(Integer, String)] -> LCalculus.ScopedTerm
fromDeBruijnScopedTerm x nameDict = case x of
  DBCalculus.ScopedTerm term -> LCalculus.ScopedTerm (fromDeBruijnTerm term nameDict)

fromDeBruijnVariable :: DBCalculus.VarIdent -> [(Integer, String)] -> LCalculus.VarIdent
fromDeBruijnVariable x nameDict = case x of
  DBCalculus.VarIdent ident -> LCalculus.VarIdent (fromDeBruijnIdent ident)
  DBCalculus.DBBound indx -> 
    case returnIdentifier nameDict indx  of 
        Just ident -> LCalculus.VarIdent (LCalculus.Ident ident)
        -- Слабое место в Nothing