-- File generated by the BNF Converter (bnfc 2.9.4.1).

-- Templates for pattern matching on abstract syntax

{-# OPTIONS_GHC -fno-warn-unused-matches #-}

module LambdaCalc.Analyser where

import Prelude (($), Either(..), String, (++), Show, show, Integer, Maybe (..), fst, snd, otherwise, (==), (+))
import qualified LambdaCalc.LambdaCalculus.Abs
import LambdaCalc.LambdaCalculus.Abs ( Program(..), Term(..), Ident(..), Variable(..) )

type Result = Either String Program

updateValues :: [(String, Integer)] -> [(String, Integer)]
updateValues [] = []
updateValues (x:xs) = (fst x, snd x + 1) : updateValues xs

printValues :: [(String, Integer)] -> String
printValues [] = ""
printValues (x:xs) = (fst x) ++ " => " ++ show (snd x) ++ "\n" ++ printValues xs

returnIndex :: [(String, Integer)] -> String -> Maybe Integer
returnIndex [] value = Nothing
returnIndex (x:xs) value
    | fst x == value = Just (snd x)
    | otherwise = returnIndex xs value


failure :: Show a => a -> Either String String
failure x = Left $ "Undefined case: " ++ show x

addValue :: [(String, Integer)] -> String -> [(String, Integer)]
addValue [] value = [(value, 0)]
addValue (x:xs) value 
  | fst x == value = (fst x, 0) : xs
  | otherwise = x : (addValue xs value)



transIdent :: Ident -> Either String Ident
transIdent x = case x of
  Ident string -> Right (Ident string)
  _ -> Left $ "Unexpected case: " ++ show x

transProgram :: Program -> Either String Program
transProgram x = case x of
    AProgram term -> do 
      case transTerm term [] of 
        Left err -> Left err
        Right terms -> Right (AProgram terms)
    _ -> Left $ "Unexpected case: " ++ show x

transTerm :: Term -> [(String, Integer)] -> Either String Term
transTerm x nameDict = case x of
  Var variable -> 
    case transVariable variable nameDict of 
      Left err -> Left err
      Right newVar -> Right (Var newVar)
  IntConst integer -> Right (IntConst integer)
  DoubleConst double -> Right (DoubleConst double)
  Binder variable term -> do 
    case variable of 
      Identifier (Ident varName) ->
        case transTerm term (addValue (updateValues nameDict) varName) of 
          Left err -> Left err
          Right term -> Right (Binder (Identifier (Ident "")) term)
      
  Application term1 term2 -> do 
    case transTerm term1 nameDict of 
      Left err -> Left err
      Right updatedTerm1 -> do 
        case transTerm term2 nameDict of
          Left err -> Left err
          Right updatedTerm2 -> Right (Application updatedTerm1 updatedTerm2)

  Plus term1 term2 -> do 
    case transTerm term1 nameDict of 
      Left err -> Left err
      Right updatedTerm1 -> do 
        case transTerm term2 nameDict of
          Left err -> Left err
          Right updatedTerm2 -> Right (Plus updatedTerm1 updatedTerm2)

  Minus term1 term2 ->  do 
    case transTerm term1 nameDict of 
      Left err -> Left err
      Right updatedTerm1 -> do 
        case transTerm term2 nameDict of
          Left err -> Left err
          Right updatedTerm2 -> Right (Minus updatedTerm1 updatedTerm2)

transVariable :: Variable -> [(String, Integer)] -> Either String Variable
transVariable x nameDict = case x of
  Identifier ident -> 
    case transIdent ident of
      Right (Ident string) -> 
        case returnIndex nameDict string of 
          Nothing -> Right (Identifier ident)
          Just index -> Right (Bound index)
      _ -> Left $ "Unexpected case: " ++ show x;
  Bound integer -> Right (Bound integer)