-- File generated by the BNF Converter (bnfc 2.9.4.1).

-- Templates for pattern matching on abstract syntax

{-# OPTIONS_GHC -fno-warn-unused-matches #-}

module LambdaCalc.IndexedTreeParser where

import Prelude (($), Either(..), String, (++), Show, show, (+))
import qualified LambdaCalc.LambdaCalculus.Abs
import LambdaCalc.LambdaCalculus.Abs ( Program(..), Term(..), Ident(..), Variable(..) )
import LambdaCalc.Substitute ( substTerm )
import LambdaCalc.ShiftFunction ( shiftTerm )


parseIndexedIdent :: Ident -> Ident
parseIndexedIdent x = case x of
  Ident string -> Ident string

parseIndexedProgram :: Program -> Program
parseIndexedProgram x = case x of
  AProgram term -> AProgram (parseIndexedTerm term)

parseIndexedTerm :: Term -> Term
parseIndexedTerm x = case x of
  Var variable -> Var (parseIndexedVariable variable)
  IntConst integer -> x
  DoubleConst double -> x
  Binder variable term -> Binder (parseIndexedVariable variable) (parseIndexedTerm term)
  Application term1 term2 -> do
    let newTerm1 = (parseIndexedTerm term1)
    let newTerm2 = (parseIndexedTerm term2)
    case newTerm1 of 
      Binder variable binderTerm -> do 
        let beforeDownShift = substTerm binderTerm 0 newTerm2
        shiftTerm beforeDownShift 1 (-1)
      _ -> Application newTerm1 newTerm2
    
  Plus term1 term2 -> Plus (parseIndexedTerm term1) (parseIndexedTerm term2)
  Minus term1 term2 -> Minus (parseIndexedTerm term1) (parseIndexedTerm term2)

parseIndexedVariable :: Variable -> Variable
parseIndexedVariable x = case x of
  Identifier ident -> Identifier ident
  Bound integer -> Bound integer
