-- File generated by the BNF Converter (bnfc 2.9.4.1).

-- Templates for pattern matching on abstract syntax

{-# OPTIONS_GHC -fno-warn-unused-matches #-}

module LambdaCalc.ShiftFunction where

import Prelude (($), String, (++), (>), (>=), Show, show, Integer, Maybe (..), fst, snd, otherwise, (==), (+))
import qualified LambdaCalc.LambdaCalculus.Abs
import LambdaCalc.LambdaCalculus.Abs ( Program(..), Term(..), Ident(..), Variable(..) )


shiftIdent :: Ident -> Ident
shiftIdent x = case x of
  Ident string -> Ident string

shiftTerm :: Term -> Integer -> (Integer -> Integer) -> Term
shiftTerm x cutoff func = case x of
  Var variable -> Var (shiftVariable variable cutoff func) 
  IntConst integer -> IntConst integer
  DoubleConst double -> DoubleConst double
  Binder variable term -> 
    Binder (shiftVariable variable cutoff func) (shiftTerm term (cutoff+1) func)
  Application term1 term2 ->
    Application (shiftTerm term1 cutoff func) (shiftTerm term2 cutoff func)
  Plus term1 term2 -> 
    Plus (shiftTerm term1 cutoff func) (shiftTerm term2 cutoff func)
  Minus term1 term2 ->
    Minus (shiftTerm term1 cutoff func) (shiftTerm term2 cutoff func)
    
shiftVariable :: Variable -> Integer -> (Integer -> Integer) -> Variable
shiftVariable x cutoff func = case x of
  Identifier ident -> Identifier (shiftIdent ident)
  Bound integer -> 
    if (integer >= cutoff)
      then Bound (func integer)
      else Bound integer
