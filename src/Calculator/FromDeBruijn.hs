-- File generated by the BNF Converter (bnfc 2.9.4.1).

-- Templates for pattern matching on abstract syntax

{-# OPTIONS_GHC -fno-warn-unused-matches #-}

module FromDeBruĳn where

import Prelude (($), Either(..), String, (++), Show, fromIntegral, show, Integer, Maybe (..), fst, snd, mod, otherwise, (==), (<), (+), map, foldr, Num (fromInteger), Integral (toInteger), Foldable (foldl), const, length)
import Data.Char (chr)
import Data.Text.Internal.Fusion (Stream, index, length)
import qualified LCalc.LambdaCalculus.Abs as LCalculus
import qualified DBruijnCalc.DeBruijnGrammar.Abs as DBCalculus


upShiftDict :: [(Integer, String)] -> [(Integer, String)]
upShiftDict = map (\ x -> (fst x + 1, snd x))

returnIdentifier :: [(Integer, String)] -> Integer -> Maybe String
returnIdentifier [] indx = Nothing
returnIdentifier (x:xs) indx
    | fst x == indx = Just (snd x)
    | otherwise = returnIdentifier xs indx

intToString :: Integer -> String
intToString n 
    | n < 0 = []
    | otherwise = chr (97 + (fromIntegral n `mod` 26)) : intToString (n + (-26))

addIdentifier :: [(Integer, String)] -> Integer -> [(Integer, String)]
addIdentifier xs length = foldr (:) [(0, intToString length)] xs


fromDeBruĳnIdent :: DBCalculus.Ident -> LCalculus.Ident
fromDeBruĳnIdent x = case x of
  DBCalculus.Ident string -> LCalculus.Ident string

fromDeBruĳn :: DBCalculus.Program -> LCalculus.Program
fromDeBruĳn prog = case prog of
    DBCalculus.AProgram terms -> LCalculus.AProgram (map (\ x -> fromDeBruĳnTerm x []) terms)

fromDeBruĳnTerm :: DBCalculus.Term -> [(Integer, String)] -> LCalculus.Term
fromDeBruĳnTerm x nameDict = case x of
  DBCalculus.Var variable -> LCalculus.Var (fromDeBruĳnVariable variable nameDict) 
  DBCalculus.IntConst integer -> LCalculus.IntConst integer
  DBCalculus.DoubleConst double -> LCalculus.DoubleConst double
  DBCalculus.Binder term -> do 
    let dictTermScope = upShiftDict nameDict
    let dictLength = toInteger (Prelude.length dictTermScope)
    let dictWithVar = addIdentifier dictTermScope dictLength
    let updatedTerm = fromDeBruĳnTerm term dictWithVar 
    LCalculus.Binder (LCalculus.Identifier (LCalculus.Ident (intToString dictLength))) updatedTerm
      
  DBCalculus.LetBinder term1 term2 -> do
    let updatedTerm1 = fromDeBruĳnTerm term1 nameDict 

    let dictTermScope = upShiftDict nameDict
    let dictLength = toInteger (Prelude.length dictTermScope)
    let dictWithVar = addIdentifier dictTermScope dictLength
    let updatedTerm2 = fromDeBruĳnTerm term2 dictWithVar 
    
    LCalculus.LetBinder (LCalculus.Identifier (LCalculus.Ident (intToString dictLength))) updatedTerm1 updatedTerm2

  DBCalculus.Application term1 term2 -> do 
    let updatedTerm1 = fromDeBruĳnTerm term1 nameDict 
    let updatedTerm2 = fromDeBruĳnTerm term2 nameDict 
    LCalculus.Application updatedTerm1 updatedTerm2

  DBCalculus.Plus term1 term2 -> do 
    let updatedTerm1 = fromDeBruĳnTerm term1 nameDict 
    let updatedTerm2 = fromDeBruĳnTerm term2 nameDict
    LCalculus.Plus updatedTerm1 updatedTerm2

  DBCalculus.Minus term1 term2 ->  do 
    let updatedTerm1 = fromDeBruĳnTerm term1 nameDict
    let updatedTerm2 = fromDeBruĳnTerm term2 nameDict
    LCalculus.Minus updatedTerm1 updatedTerm2

fromDeBruĳnVariable :: DBCalculus.Variable -> [(Integer, String)] -> LCalculus.Variable
fromDeBruĳnVariable x nameDict = case x of
  DBCalculus.Identifier ident -> LCalculus.Identifier (fromDeBruĳnIdent ident)
  DBCalculus.Bound indx -> 
    case returnIdentifier nameDict indx  of 
        Just ident -> LCalculus.Identifier (LCalculus.Ident ident)
        -- Слабое место в Nothing