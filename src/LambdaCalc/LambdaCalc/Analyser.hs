-- File generated by the BNF Converter (bnfc 2.9.4.1).

-- Templates for pattern matching on abstract syntax

{-# OPTIONS_GHC -fno-warn-unused-matches #-}

module LambdaCalc.Analyser where

import Prelude (($), Either(..), String, (++), Show, show, Int, Maybe (..), fst, snd, otherwise, (==), (+))
import qualified LambdaCalc.LambdaCalculus.Abs

type Err = Either String
type Result = Err String

updateValues :: [(String, Int)] -> [(String, Int)]
updateValues [] = []
updateValues (x:xs) = (fst x, snd x + 1) : updateValues xs

printValues :: [(String, Int)] -> String
printValues [] = ""
printValues (x:xs) = (fst x) ++ " => " ++ show (snd x) ++ "\n" ++ printValues xs

returnIndex :: [(String, Int)] -> String -> Maybe Int
returnIndex [] value = Nothing
returnIndex (x:xs) value
    | fst x == value = Just (snd x)
    | otherwise = returnIndex xs value


failure :: Show a => a -> Result
failure x = Left $ "Undefined case: " ++ show x

transIdent :: LambdaCalc.LambdaCalculus.Abs.Ident -> Result
transIdent x = case x of
  LambdaCalc.LambdaCalculus.Abs.Ident string -> Right string
  _ -> Left $ "Unexpected case: " ++ show x

transProgram :: LambdaCalc.LambdaCalculus.Abs.Program -> Result
transProgram x = case x of
    LambdaCalc.LambdaCalculus.Abs.AProgram term -> do transTerm term []
    _ -> Left $ "Unexpected case: " ++ show x

addValue :: [(String, Int)] -> String -> [(String, Int)]
addValue [] value = [(value, 1)]
addValue (x:xs) value 
  | fst x == value = (fst x, 1) : xs
  | otherwise = x : (addValue xs value)


transTerm :: LambdaCalc.LambdaCalculus.Abs.Term -> [(String, Int)] -> Result
transTerm x nameDict = case x of
  LambdaCalc.LambdaCalculus.Abs.Var variable -> do 
    case transVariable variable of
      Left err -> Left err
      Right string -> do
        case returnIndex nameDict string of 
          Nothing -> Left $ "Unexpectable variable: " ++ string
          Just a -> Right (show a)

  LambdaCalc.LambdaCalculus.Abs.IntConst integer -> Right (show integer)
  LambdaCalc.LambdaCalculus.Abs.DoubleConst double -> Right (show double)
  LambdaCalc.LambdaCalculus.Abs.Binder variable term -> do 
    varName <- transVariable variable
    case transTerm term ( addValue (updateValues nameDict) varName) of 
      Left err -> Left err
      Right string -> Right $ "lambda " ++ string
    
  LambdaCalc.LambdaCalculus.Abs.Application term1 term2 -> do 
    case transTerm term1 nameDict of 
      Left err -> Left err
      Right stringTerm1 -> do 
        case transTerm term2 nameDict of
          Left err -> Left err
          Right stringTerm2 -> Right $ "(" ++ stringTerm1 ++ " " ++ stringTerm2 ++ ")"

  LambdaCalc.LambdaCalculus.Abs.Plus term1 term2 -> do 
    case transTerm term1 nameDict of 
      Left err -> Left err
      Right stringTerm1 -> do 
        case transTerm term2 nameDict of
          Left err -> Left err
          Right stringTerm2 -> Right $ stringTerm1 ++ " + " ++ stringTerm2

  LambdaCalc.LambdaCalculus.Abs.Minus term1 term2 ->  do 
    case transTerm term1 nameDict of 
      Left err -> Left err
      Right stringTerm1 -> do 
        case transTerm term2 nameDict of
          Left err -> Left err
          Right stringTerm2 -> Right $ stringTerm1 ++ " - " ++ stringTerm2

transVariable :: LambdaCalc.LambdaCalculus.Abs.Variable -> Result
transVariable x = case x of
  LambdaCalc.LambdaCalculus.Abs.Identifier ident -> transIdent ident
