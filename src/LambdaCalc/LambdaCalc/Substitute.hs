-- File generated by the BNF Converter (bnfc 2.9.4.1).

-- Templates for pattern matching on abstract syntax

{-# OPTIONS_GHC -fno-warn-unused-matches #-}

module LambdaCalc.Substitute where

import Prelude (($), Either(..), String, (++), Show, show, Int, Maybe (..), fst, snd, otherwise, (==), (+))
import qualified LambdaCalc.LambdaCalculus.Abs

type Result = Either String LambdaCalc.LambdaCalculus.Abs.Program
type SubstitutionTerm = Maybe LambdaCalc.LambdaCalculus.Abs.Term

failure :: Show a => a -> Either String String
failure x = Left $ "Undefined case: " ++ show x


substIdent :: LambdaCalc.LambdaCalculus.Abs.Ident -> Either String LambdaCalc.LambdaCalculus.Abs.Ident
substIdent x = case x of
  LambdaCalc.LambdaCalculus.Abs.Ident string -> Right (LambdaCalc.LambdaCalculus.Abs.Ident string)

substProgram :: LambdaCalc.LambdaCalculus.Abs.Program -> Either String LambdaCalc.LambdaCalculus.Abs.Program
substProgram x = case x of
    LambdaCalc.LambdaCalculus.Abs.AProgram term -> do 
      case substTerm term 0 Nothing of 
        Left err -> Left err
        Right terms -> Right (LambdaCalc.LambdaCalculus.Abs.AProgram terms)

substTerm :: LambdaCalc.LambdaCalculus.Abs.Term -> Int -> SubstitutionTerm -> Either String LambdaCalc.LambdaCalculus.Abs.Term
substTerm x substNumber newTerm = case x of
  (LambdaCalc.LambdaCalculus.Abs.Var (LambdaCalc.LambdaCalculus.Abs.Identifier (LambdaCalc.LambdaCalculus.Abs.Ident index))) ->
    case newTerm of 
      Nothing -> Right x
      Just nt -> 
        if show (substNumber) == index 
          then Right nt
          else Right x

  LambdaCalc.LambdaCalculus.Abs.IntConst integer -> Right (LambdaCalc.LambdaCalculus.Abs.IntConst integer)
  LambdaCalc.LambdaCalculus.Abs.DoubleConst double -> Right (LambdaCalc.LambdaCalculus.Abs.DoubleConst double)
  LambdaCalc.LambdaCalculus.Abs.Binder variable term -> 
    case newTerm of 
      Nothing -> Right x
      Just nt -> case (substTerm term (substNumber+1) newTerm) of 
                  Left a -> Left a
                  Right b -> Right (LambdaCalc.LambdaCalculus.Abs.Binder variable b)
  LambdaCalc.LambdaCalculus.Abs.Application term1 term2 -> do 
    newTerm1 <- substTerm term1 substNumber newTerm
    newTerm2 <- substTerm term2 substNumber newTerm
    case newTerm1 of 
      LambdaCalc.LambdaCalculus.Abs.Binder v binderTerm ->
        substTerm binderTerm 0 (Just newTerm2)
      _ -> Right (LambdaCalc.LambdaCalculus.Abs.Application newTerm1 newTerm2)

  LambdaCalc.LambdaCalculus.Abs.Plus term1 term2 -> do 
    newTerm1 <- substTerm term1 substNumber newTerm
    newTerm2 <- substTerm term2 substNumber newTerm
    Right (LambdaCalc.LambdaCalculus.Abs.Plus newTerm1 newTerm2)

  LambdaCalc.LambdaCalculus.Abs.Minus term1 term2 ->  do
    newTerm1 <- substTerm term1 substNumber newTerm
    newTerm2 <- substTerm term2 substNumber newTerm
    Right (LambdaCalc.LambdaCalculus.Abs.Minus newTerm1 newTerm2)

substVariable :: LambdaCalc.LambdaCalculus.Abs.Variable -> Either String String
substVariable x = case x of
  LambdaCalc.LambdaCalculus.Abs.Identifier ident -> case substIdent ident of
    Right (LambdaCalc.LambdaCalculus.Abs.Ident string) -> Right string
    _ -> Left $ "Unexpected case: " ++ show x
