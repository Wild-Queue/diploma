-- File generated by the BNF Converter (bnfc 2.9.4.1).

-- Templates for pattern matching on abstract syntax

{-# OPTIONS_GHC -fno-warn-unused-matches #-}

module Substitute where

import Prelude (($), Either(..), String, (++), Show, show, Integer, Maybe (..), fst, snd, otherwise, (==), (+))
import qualified DBruijnCalc.DeBruijnGrammar.Abs
import DBruijnCalc.DeBruijnGrammar.Abs ( Program(..), Term(..), Ident(..), VarIdent(..), ScopedTerm(..))
import ShiftFunction ( shiftTerm )


substIdent :: Ident -> Ident
substIdent x = case x of
  Ident string -> Ident string

substTerm :: Term -> Integer -> Term -> Term
substTerm x substIndex newTerm = case x of
  Var variable ->
    case substVariable variable of 
      Left identifier -> Var identifier
      Right index -> 
        if substIndex == index 
          then shiftTerm newTerm 0 substIndex
          else Var (DBBound index)

  Lam term ->
    case term of 
      ScopedTerm term -> Lam (ScopedTerm (substTerm term (substIndex+1) newTerm))

  Let term1 term2 -> 
    case term2 of 
      ScopedTerm term2 -> do
        let newTerm1 = substTerm term1 substIndex newTerm
        let newTerm2 = substTerm term2 (substIndex+1) newTerm
        let beforeDownShift = substTerm newTerm2 0 newTerm1
        shiftTerm beforeDownShift 1 (-1)

  Application term1 term2 -> do 
    let newTerm1 = substTerm term1 substIndex newTerm
    let newTerm2 = substTerm term2 substIndex newTerm
    case newTerm1 of 
      Lam (ScopedTerm binderTerm) -> do 
        let beforeDownShift = substTerm binderTerm 0 newTerm2
        shiftTerm beforeDownShift 1 (-1)
      _ -> Application newTerm1 newTerm2

substVariable :: VarIdent -> Either VarIdent Integer
substVariable x = case x of
  VarIdent ident -> Left (VarIdent (substIdent ident))
  DBBound integer -> Right integer
